/*! @asymmetrik/ngx-leaflet - 2.4.0 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. + */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("leaflet")):"function"==typeof define&&define.amd?define(["exports","@angular/core","leaflet"],t):t(e.ngxLeaflet={},e.ng.core,e.L)}(this,function(e,t,r){"use strict";var n=function(){function e(e){this.DEFAULT_ZOOM=1,this.DEFAULT_CENTER=r.latLng([38.907192,-77.036871]),this.DEFAULT_FPZ_OPTIONS={},this.fitBoundsOptions=this.DEFAULT_FPZ_OPTIONS,this.panOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomPanOptions=this.DEFAULT_FPZ_OPTIONS,
// Default configuration
this.options={},
// Configure callback function for the map
this.mapReady=new t.EventEmitter,this.element=e}/**
     * Resize the map to fit it's parent container
     */
/**
     * Manage a delayed resize of the component
     */
/**
     * Set the view (center/zoom) all at once
     * @param center The new center
     * @param zoom The new zoom level
     */
/**
     * Set the map zoom level
     * @param zoom the new zoom level for the map
     */
/**
     * Set the center of the map
     * @param center the center point
     */
/**
     * Fit the map to the bounds
     * @param center the center point
     */
return e.prototype.ngOnInit=function(){
// Create the map with some reasonable defaults
this.map=r.map(this.element.nativeElement,this.options),
// Only setView if there is a center/zoom
null!=this.center&&null!=this.zoom&&this.setView(this.center,this.zoom),
// Set up all the initial settings
null!=this.fitBounds&&this.setFitBounds(this.fitBounds),this.doResize(),
// Fire map ready event
this.mapReady.emit(this.map)},e.prototype.ngOnChanges=function(e){/*
         * The following code is to address an issue with our (basic) implementation of
         * zooming and panning. From our testing, it seems that a pan operation followed
         * by a zoom operation in the same thread will interfere with eachother. The zoom
         * operation interrupts/cancels the pan, resulting in a final center point that is
         * inaccurate. The solution seems to be to either separate them with a timeout or
          * to collapse them into a setView call.
         */
// Zooming and Panning
e.zoom&&e.center&&null!=this.zoom&&null!=this.center?this.setView(e.center.currentValue,e.zoom.currentValue):e.zoom?this.setZoom(e.zoom.currentValue):e.center&&this.setCenter(e.center.currentValue),
// Fit bounds
e.fitBounds&&this.setFitBounds(e.fitBounds.currentValue)},e.prototype.getMap=function(){return this.map},e.prototype.onResize=function(){this.delayResize()},e.prototype.doResize=function(){
// Invalidate the map size to trigger it to update itself
this.map.invalidateSize({})},e.prototype.delayResize=function(){null!=this.resizeTimer&&clearTimeout(this.resizeTimer),this.resizeTimer=setTimeout(this.doResize.bind(this),200)},e.prototype.setView=function(e,t){this.map&&null!=e&&null!=t&&this.map.setView(e,t,this.zoomPanOptions)},e.prototype.setZoom=function(e){this.map&&null!=e&&this.map.setZoom(e,this.zoomOptions)},e.prototype.setCenter=function(e){this.map&&null!=e&&this.map.panTo(e,this.panOptions)},e.prototype.setFitBounds=function(e){this.map&&null!=e&&this.map.fitBounds(e,this.fitBoundsOptions)},e}();n.decorators=[{type:t.Directive,args:[{selector:"[leaflet]"}]}],/** @nocollapse */
n.ctorParameters=function(){return[{type:t.ElementRef}]},n.propDecorators={fitBoundsOptions:[{type:t.Input,args:["leafletFitBoundsOptions"]}],panOptions:[{type:t.Input,args:["leafletPanOptions"]}],zoomOptions:[{type:t.Input,args:["leafletZoomOptions"]}],zoomPanOptions:[{type:t.Input,args:["leafletZoomPanOptions"]}],options:[{type:t.Input,args:["leafletOptions"]}],mapReady:[{type:t.Output,args:["leafletMapReady"]}],zoom:[{type:t.Input,args:["leafletZoom"]}],center:[{type:t.Input,args:["leafletCenter"]}],fitBounds:[{type:t.Input,args:["leafletFitBounds"]}],onResize:[{type:t.HostListener,args:["window:resize",[]]}]};var i=function(){function e(e){this.leafletDirective=e}return e.prototype.init=function(){},e.prototype.getMap=function(){return this.leafletDirective.getMap()},e}(),s=function(){function e(e,t){this.differs=t,this.leafletDirective=new i(e),this.layersDiffer=this.differs.find([]).create()}/**
     * Update the state of the layers.
     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
     * This is important because it allows us to react to changes to the contents of the array as well
     * as changes to the actual array instance.
     */
return Object.defineProperty(e.prototype,"layers",{get:function(){return this.layersValue},
// Set/get the layers
set:function(e){this.layersValue=e,
// Now that we have a differ, do an immediate layer update
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Update layers once the map is ready
this.updateLayers()},e.prototype.updateLayers=function(){var e=this.leafletDirective.getMap();if(null!=e&&null!=this.layersDiffer){var t=this.layersDiffer.diff(this.layersValue);null!=t&&(t.forEachRemovedItem(function(t){e.removeLayer(t.item)}),t.forEachAddedItem(function(t){e.addLayer(t.item)}))}},e}();s.decorators=[{type:t.Directive,args:[{selector:"[leafletLayers]"}]}],/** @nocollapse */
s.ctorParameters=function(){return[{type:n},{type:t.IterableDiffers}]},s.propDecorators={layers:[{type:t.Input,args:["leafletLayers"]}]};var o=function(){function e(){this.layersRemoved=0,this.layersChanged=0,this.layersAdded=0}return e.prototype.changed=function(){return!(0===this.layersRemoved&&0===this.layersChanged&&0===this.layersAdded)},e}(),a=function(){function e(){}return e.prototype.getLayersControl=function(){return this.layersControl},e.prototype.init=function(e,t){var n=e.baseLayers||{},i=e.overlays||{};return this.layersControl=r.control.layers(n,i,t),this.layersControl},e.prototype.applyBaseLayerChanges=function(e){var t=new o;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addBaseLayer)),t},e.prototype.applyOverlayChanges=function(e){var t=new o;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addOverlay)),t},e.prototype.applyChanges=function(e,t){var r=this,n=new o;return null!=e&&(e.forEachChangedItem(function(e){r.layersControl.removeLayer(e.previousValue),t.call(r.layersControl,e.currentValue,e.key),n.layersChanged++}),e.forEachRemovedItem(function(e){r.layersControl.removeLayer(e.currentValue),n.layersRemoved++}),e.forEachAddedItem(function(e){t.call(r.layersControl,e.currentValue,e.key),n.layersAdded++})),n},e}(),l=function(){return function(){this.baseLayers={},this.overlays={}}}(),u=function(){function e(e,t){this.differs=t,this.leafletDirective=new i(e),this.controlLayers=new a,
// Generate differs
this.baseLayersDiffer=this.differs.find({}).create(),this.overlaysDiffer=this.differs.find({}).create()}return Object.defineProperty(e.prototype,"layersControlConfig",{get:function(){return this.layersControlConfigValue},set:function(e){
// Validation/init stuff
null==e&&(e=new l),null==e.baseLayers&&(e.baseLayers={}),null==e.overlays&&(e.overlays={}),
// Store the value
this.layersControlConfigValue=e,
// Update the map
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Set up all the initial settings
this.controlLayers.init({},this.layersControlOptions).addTo(this.leafletDirective.getMap()),this.updateLayers()},e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.updateLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t){
// Run the baselayers differ
if(null!=this.baseLayersDiffer&&null!=this.layersControlConfigValue.baseLayers){r=this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);this.controlLayers.applyBaseLayerChanges(r)}
// Run the overlays differ
if(null!=this.overlaysDiffer&&null!=this.layersControlConfigValue.overlays){var r=this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);this.controlLayers.applyOverlayChanges(r)}}},e}();u.decorators=[{type:t.Directive,args:[{selector:"[leafletLayersControl]"}]}],/** @nocollapse */
u.ctorParameters=function(){return[{type:n},{type:t.KeyValueDiffers}]},u.propDecorators={layersControlConfig:[{type:t.Input,args:["leafletLayersControl"]}],layersControlOptions:[{type:t.Input,args:["leafletLayersControlOptions"]}]};var p=function(){function e(){}return e.mapToArray=function(e){var t=[];for(var r in e)e.hasOwnProperty(r)&&t.push(e[r]);return t},e}(),f=function(){function e(e,t){this.differs=t,this.leafletDirective=new i(e),this.controlLayers=new a,this.baseLayersDiffer=this.differs.find({}).create()}/**
     * Check the current base layer and change it to the new one if necessary
     */
return Object.defineProperty(e.prototype,"baseLayers",{get:function(){return this.baseLayersValue},
// Set/get baseLayers
set:function(e){this.baseLayersValue=e,this.updateBaseLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Initially configure the controlLayers
this.controlLayers.init({},this.layersControlOptions).addTo(this.leafletDirective.getMap()),this.updateBaseLayers()},e.prototype.ngDoCheck=function(){this.updateBaseLayers()},e.prototype.updateBaseLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t&&null!=this.baseLayersDiffer){var r=this.baseLayersDiffer.diff(this.baseLayersValue);this.controlLayers.applyBaseLayerChanges(r).changed()&&this.syncBaseLayer()}},e.prototype.syncBaseLayer=function(){var e,t=this.leafletDirective.getMap(),r=p.mapToArray(this.baseLayers);
// Search all the layers in the map to see if we can find them in the baselayer array
t.eachLayer(function(t){e=r.find(function(e){return t===e})}),
// Did we find the layer?
null!=e?
// Yes - set the baselayer to the one we found
this.baseLayer=e:
// No - set the baselayer to the first in the array and add it to the map
r.length>0&&(this.baseLayer=r[0],this.baseLayer.addTo(t))},e}();f.decorators=[{type:t.Directive,args:[{selector:"[leafletBaseLayers]"}]}],/** @nocollapse */
f.ctorParameters=function(){return[{type:n},{type:t.KeyValueDiffers}]},f.propDecorators={baseLayers:[{type:t.Input,args:["leafletBaseLayers"]}],layersControlOptions:[{type:t.Input,args:["leafletLayersControlOptions"]}]};var y=function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e}();y.decorators=[{type:t.NgModule,args:[{exports:[n,s,u,f],declarations:[n,s,u,f]}]}],/** @nocollapse */
y.ctorParameters=function(){return[]};var c=function(){function e(e,t,r){this.type=e,this.url=t,this.options=r}/**
     * Creates a TileLayer from the provided definition. This is a convenience function
     * to help with generating layers from objects.
     *
     * @param layerDef The layer to create
     * @returns {L.TileLayer} The TileLayer that has been created
     */
/**
     * Creates a TileLayer for each key in the incoming map. This is a convenience function
     * for generating an associative array of layers from an associative array of objects
     *
     * @param layerDefs A map of key to tile layer definition
     * @returns {{[p: string]: L.TileLayer}} A new map of key to TileLayer
     */
/**
     * Create a Tile Layer from the current state of this object
     *
     * @returns {L.TileLayer} A new TileLayer
     */
return e.createTileLayer=function(e){var t;switch(e.type){case"xyz":t=r.tileLayer(e.url,e.options);break;case"wms":default:t=r.tileLayer.wms(e.url,e.options)}return t},e.createTileLayers=function(t){var r={};for(var n in t)t.hasOwnProperty(n)&&(r[n]=e.createTileLayer(t[n]));return r},e.prototype.createTileLayer=function(){return e.createTileLayer(this)},e}();e.LeafletModule=y,e.LeafletDirective=n,e.LeafletDirectiveWrapper=i,e.LeafletTileLayerDefinition=c,Object.defineProperty(e,"__esModule",{value:!0})});
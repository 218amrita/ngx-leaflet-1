/*! @asymmetrik/ngx-leaflet - 3.1.0 - Copyright Asymmetrik, Ltd. 2007-2018 - All Rights Reserved. + */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("leaflet")):"function"==typeof define&&define.amd?define(["exports","@angular/core","leaflet"],t):t(e.ngxLeaflet={},e.ng.core,e.L)}(this,function(e,n,a){"use strict";var t=/** @class */function(){function e(e,t){
// Nothing here
this.element=e,this.zone=t,this.DEFAULT_ZOOM=1,this.DEFAULT_CENTER=a.latLng(38.907192,-77.036871),this.DEFAULT_FPZ_OPTIONS={},this.fitBoundsOptions=this.DEFAULT_FPZ_OPTIONS,this.panOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomPanOptions=this.DEFAULT_FPZ_OPTIONS,
// Default configuration
this.options={},
// Configure callback function for the map
this.mapReady=new n.EventEmitter,this.zoomChange=new n.EventEmitter,this.centerChange=new n.EventEmitter,
// Mouse Map Events
this.onClick=new n.EventEmitter,this.onDoubleClick=new n.EventEmitter,this.onMouseDown=new n.EventEmitter,this.onMouseUp=new n.EventEmitter,this.onMouseMove=new n.EventEmitter,this.onMouseOver=new n.EventEmitter,
// Map Move Events
this.onMapMove=new n.EventEmitter,this.onMapMoveStart=new n.EventEmitter,this.onMapMoveEnd=new n.EventEmitter,
// Map Zoom Events
this.onMapZoom=new n.EventEmitter,this.onMapZoomStart=new n.EventEmitter,this.onMapZoomEnd=new n.EventEmitter}return e.prototype.ngOnInit=function(){var e=this;
// Create the map outside of angular so the various map events don't trigger change detection
this.zone.runOutsideAngular(function(){
// Create the map with some reasonable defaults
// Create the map with some reasonable defaults
e.map=a.map(e.element.nativeElement,e.options),e.addMapEventListeners()}),
// Only setView if there is a center/zoom
null!=this.center&&null!=this.zoom&&this.setView(this.center,this.zoom),
// Set up all the initial settings
null!=this.fitBounds&&this.setFitBounds(this.fitBounds),null!=this.maxBounds&&this.setMaxBounds(this.maxBounds),null!=this.minZoom&&this.setMinZoom(this.minZoom),null!=this.maxZoom&&this.setMaxZoom(this.maxZoom),this.doResize(),
// Fire map ready event
this.mapReady.emit(this.map)},e.prototype.ngOnChanges=function(e){
/*
                 * The following code is to address an issue with our (basic) implementation of
                 * zooming and panning. From our testing, it seems that a pan operation followed
                 * by a zoom operation in the same thread will interfere with eachother. The zoom
                 * operation interrupts/cancels the pan, resulting in a final center point that is
                 * inaccurate. The solution seems to be to either separate them with a timeout or
                  * to collapse them into a setView call.
                 */
// Zooming and Panning
e.zoom&&e.center&&null!=this.zoom&&null!=this.center?this.setView(e.center.currentValue,e.zoom.currentValue):e.zoom?this.setZoom(e.zoom.currentValue):e.center&&this.setCenter(e.center.currentValue),
// Other options
e.fitBounds&&this.setFitBounds(e.fitBounds.currentValue),e.maxBounds&&this.setMaxBounds(e.maxBounds.currentValue),e.minZoom&&this.setMinZoom(e.minZoom.currentValue),e.maxZoom&&this.setMaxZoom(e.maxZoom.currentValue)},e.prototype.getMap=function(){return this.map},e.prototype.onResize=function(){this.delayResize()},e.prototype.handleEvent=function(e,t){
// Don't want to emit if there are no observers
0<e.observers.length&&this.zone.run(function(){e.emit(t)})},e.prototype.addMapEventListeners=function(){var n=this;
// Add all the pass-through mouse event handlers
this.map.on("click",function(e){return n.handleEvent(n.onClick,e)}),this.map.on("dblclick",function(e){return n.handleEvent(n.onDoubleClick,e)}),this.map.on("mousedown",function(e){return n.handleEvent(n.onMouseDown,e)}),this.map.on("mouseup",function(e){return n.handleEvent(n.onMouseUp,e)}),this.map.on("mouseover",function(e){return n.handleEvent(n.onMouseOver,e)}),this.map.on("mousemove",function(e){return n.handleEvent(n.onMouseMove,e)}),this.map.on("zoomstart",function(e){return n.handleEvent(n.onMapZoomStart,e)}),this.map.on("zoom",function(e){return n.handleEvent(n.onMapZoom,e)}),this.map.on("zoomend",function(e){return n.handleEvent(n.onMapZoomEnd,e)}),this.map.on("movestart",function(e){return n.handleEvent(n.onMapMoveStart,e)}),this.map.on("move",function(e){return n.handleEvent(n.onMapMove,e)}),this.map.on("moveend",function(e){return n.handleEvent(n.onMapMoveEnd,e)}),
// Update any things for which we provide output bindings
this.map.on("zoomend moveend",function(){var e=n.map.getZoom();e!==n.zoom&&(n.zoom=e,n.handleEvent(n.zoomChange,e));var t=n.map.getCenter();null==t&&null==n.center||(null!=t&&null!=n.center||t===n.center)&&t.lat===n.center.lat&&t.lng===n.center.lng||(n.center=t,n.handleEvent(n.centerChange,t))})},
/**
     * Resize the map to fit it's parent container
     */
/**
         * Resize the map to fit it's parent container
         */
e.prototype.doResize=
/**
         * Resize the map to fit it's parent container
         */
function(){var e=this;
// Run this outside of angular so the map events stay outside of angular
this.zone.runOutsideAngular(function(){
// Invalidate the map size to trigger it to update itself
// Invalidate the map size to trigger it to update itself
e.map.invalidateSize({})})},
/**
     * Manage a delayed resize of the component
     */
/**
         * Manage a delayed resize of the component
         */
e.prototype.delayResize=
/**
         * Manage a delayed resize of the component
         */
function(){null!=this.resizeTimer&&clearTimeout(this.resizeTimer),this.resizeTimer=setTimeout(this.doResize.bind(this),200)},
/**
     * Set the view (center/zoom) all at once
     * @param center The new center
     * @param zoom The new zoom level
     */
/**
         * Set the view (center/zoom) all at once
         * @param center The new center
         * @param zoom The new zoom level
         */
e.prototype.setView=
/**
         * Set the view (center/zoom) all at once
         * @param center The new center
         * @param zoom The new zoom level
         */
function(e,t){this.map&&null!=e&&null!=t&&this.map.setView(e,t,this.zoomPanOptions)},
/**
     * Set the map zoom level
     * @param zoom the new zoom level for the map
     */
/**
         * Set the map zoom level
         * @param zoom the new zoom level for the map
         */
e.prototype.setZoom=
/**
         * Set the map zoom level
         * @param zoom the new zoom level for the map
         */
function(e){this.map&&null!=e&&this.map.setZoom(e,this.zoomOptions)},
/**
     * Set the center of the map
     * @param center the center point
     */
/**
         * Set the center of the map
         * @param center the center point
         */
e.prototype.setCenter=
/**
         * Set the center of the map
         * @param center the center point
         */
function(e){this.map&&null!=e&&this.map.panTo(e,this.panOptions)},
/**
     * Fit the map to the bounds
     * @param latLngBounds the boundary to set
     */
/**
         * Fit the map to the bounds
         * @param latLngBounds the boundary to set
         */
e.prototype.setFitBounds=
/**
         * Fit the map to the bounds
         * @param latLngBounds the boundary to set
         */
function(e){this.map&&null!=e&&this.map.fitBounds(e,this.fitBoundsOptions)},
/**
     * Set the map's max bounds
     * @param latLngBounds the boundary to set
     */
/**
         * Set the map's max bounds
         * @param latLngBounds the boundary to set
         */
e.prototype.setMaxBounds=
/**
         * Set the map's max bounds
         * @param latLngBounds the boundary to set
         */
function(e){this.map&&null!=e&&this.map.setMaxBounds(e)},
/**
     * Set the map's min zoom
     * @param number the new min zoom
     */
/**
         * Set the map's min zoom
         * @param number the new min zoom
         */
e.prototype.setMinZoom=
/**
         * Set the map's min zoom
         * @param number the new min zoom
         */
function(e){this.map&&null!=e&&this.map.setMinZoom(e)},
/**
     * Set the map's min zoom
     * @param number the new min zoom
     */
/**
         * Set the map's min zoom
         * @param number the new min zoom
         */
e.prototype.setMaxZoom=
/**
         * Set the map's min zoom
         * @param number the new min zoom
         */
function(e){this.map&&null!=e&&this.map.setMaxZoom(e)},e.decorators=[{type:n.Directive,args:[{selector:"[leaflet]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:n.ElementRef},{type:n.NgZone}]},e.propDecorators={fitBoundsOptions:[{type:n.Input,args:["leafletFitBoundsOptions"]}],panOptions:[{type:n.Input,args:["leafletPanOptions"]}],zoomOptions:[{type:n.Input,args:["leafletZoomOptions"]}],zoomPanOptions:[{type:n.Input,args:["leafletZoomPanOptions"]}],options:[{type:n.Input,args:["leafletOptions"]}],mapReady:[{type:n.Output,args:["leafletMapReady"]}],zoom:[{type:n.Input,args:["leafletZoom"]}],zoomChange:[{type:n.Output,args:["leafletZoomChange"]}],center:[{type:n.Input,args:["leafletCenter"]}],centerChange:[{type:n.Output,args:["leafletCenterChange"]}],fitBounds:[{type:n.Input,args:["leafletFitBounds"]}],maxBounds:[{type:n.Input,args:["leafletMaxBounds"]}],minZoom:[{type:n.Input,args:["leafletMinZoom"]}],maxZoom:[{type:n.Input,args:["leafletMaxZoom"]}],onClick:[{type:n.Output,args:["leafletClick"]}],onDoubleClick:[{type:n.Output,args:["leafletDoubleClick"]}],onMouseDown:[{type:n.Output,args:["leafletMouseDown"]}],onMouseUp:[{type:n.Output,args:["leafletMouseUp"]}],onMouseMove:[{type:n.Output,args:["leafletMouseMove"]}],onMouseOver:[{type:n.Output,args:["leafletMouseOver"]}],onMapMove:[{type:n.Output,args:["leafletMapMove"]}],onMapMoveStart:[{type:n.Output,args:["leafletMapMoveStart"]}],onMapMoveEnd:[{type:n.Output,args:["leafletMapMoveEnd"]}],onMapZoom:[{type:n.Output,args:["leafletMapZoom"]}],onMapZoomStart:[{type:n.Output,args:["leafletMapZoomStart"]}],onMapZoomEnd:[{type:n.Output,args:["leafletMapZoomEnd"]}],onResize:[{type:n.HostListener,args:["window:resize",[]]}]},e}(),o=/** @class */function(){function e(e){this.leafletDirective=e}return e.prototype.init=function(){
// Nothing for now
},e.prototype.getMap=function(){return this.leafletDirective.getMap()},e}(),r=/** @class */function(){function e(e,t){this.zone=t,
// Layer Events
this.onAdd=new n.EventEmitter,this.onRemove=new n.EventEmitter,this.leafletDirective=new o(e)}return e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init()},e.prototype.ngOnDestroy=function(){this.layer.remove()},e.prototype.ngOnChanges=function(e){var t=this;if(e.layer){
// Update the layer
var n=e.layer.previousValue,o=e.layer.currentValue;this.zone.runOutsideAngular(function(){null!=n&&n.remove(),null!=o&&(t.addLayerEventListeners(o),t.leafletDirective.getMap().addLayer(o))})}},e.prototype.handleEvent=function(e,t){
// Don't want to emit if there are no observers
0<e.observers.length&&this.zone.run(function(){e.emit(t)})},e.prototype.addLayerEventListeners=function(e){var t=this;e.on("add",function(e){return t.handleEvent(t.onAdd,e)}),e.on("remove",function(e){return t.handleEvent(t.onRemove,e)})},e.decorators=[{type:n.Directive,args:[{selector:"[leafletLayer]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:t},{type:n.NgZone}]},e.propDecorators={layer:[{type:n.Input,args:["leafletLayer"]}],onAdd:[{type:n.Output,args:["leafletLayerAdd"]}],onRemove:[{type:n.Output,args:["leafletLayerRemove"]}]},e}(),s=/** @class */function(){function e(e,t,n){this.differs=t,this.zone=n,this.leafletDirective=new o(e),this.layersDiffer=this.differs.find([]).create()}return Object.defineProperty(e.prototype,"layers",{get:function(){return this.layersValue},set:
// Set/get the layers
function(e){this.layersValue=e,
// Now that we have a differ, do an immediate layer update
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Update layers once the map is ready
this.updateLayers()},e.prototype.ngOnDestroy=function(){this.layers=[]},
/**
     * Update the state of the layers.
     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
     * This is important because it allows us to react to changes to the contents of the array as well
     * as changes to the actual array instance.
     */
/**
         * Update the state of the layers.
         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
         * This is important because it allows us to react to changes to the contents of the array as well
         * as changes to the actual array instance.
         */
e.prototype.updateLayers=
/**
         * Update the state of the layers.
         * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
         * This is important because it allows us to react to changes to the contents of the array as well
         * as changes to the actual array instance.
         */
function(){var t=this.leafletDirective.getMap();if(null!=t&&null!=this.layersDiffer){var e=this.layersDiffer.diff(this.layersValue);null!=e&&
// Run outside angular to ensure layer events don't trigger change detection
this.zone.runOutsideAngular(function(){e.forEachRemovedItem(function(e){t.removeLayer(e.item)}),e.forEachAddedItem(function(e){t.addLayer(e.item)})})}},e.decorators=[{type:n.Directive,args:[{selector:"[leafletLayers]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:t},{type:n.IterableDiffers},{type:n.NgZone}]},e.propDecorators={layers:[{type:n.Input,args:["leafletLayers"]}]},e}(),i=/** @class */function(){function e(){this.layersRemoved=0,this.layersChanged=0,this.layersAdded=0}return e.prototype.changed=function(){return!(0===this.layersRemoved&&0===this.layersChanged&&0===this.layersAdded)},e}(),l=/** @class */function(){function e(e){
// Nothing here
this.zone=e}return e.prototype.getLayersControl=function(){return this.layersControl},e.prototype.init=function(e,t){var n=this,o=e.baseLayers||{},r=e.overlays||{};
// Create the control outside of angular to ensure events don't trigger change detection
return this.zone.runOutsideAngular(function(){n.layersControl=a.control.layers(o,r,t)}),this.layersControl},e.prototype.applyBaseLayerChanges=function(e){var t=new i;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addBaseLayer)),t},e.prototype.applyOverlayChanges=function(e){var t=new i;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addOverlay)),t},e.prototype.applyChanges=function(e,t){var n=this,o=new i;return null!=e&&
// All layer management is outside angular to avoid layer events from triggering change detection
this.zone.runOutsideAngular(function(){e.forEachChangedItem(function(e){n.layersControl.removeLayer(e.previousValue),t.call(n.layersControl,e.currentValue,e.key),o.layersChanged++}),e.forEachRemovedItem(function(e){n.layersControl.removeLayer(e.previousValue),o.layersRemoved++}),e.forEachAddedItem(function(e){t.call(n.layersControl,e.currentValue,e.key),o.layersAdded++})}),o},e}(),u=function(){this.baseLayers={},this.overlays={}},p=/** @class */function(){function e(e,t,n){this.differs=t,this.zone=n,this.leafletDirective=new o(e),this.controlLayers=new l(this.zone),
// Generate differs
this.baseLayersDiffer=this.differs.find({}).create(),this.overlaysDiffer=this.differs.find({}).create()}return Object.defineProperty(e.prototype,"layersControlConfig",{get:function(){return this.layersControlConfigValue},set:function(e){
// Validation/init stuff
null==e&&(e=new u),null==e.baseLayers&&(e.baseLayers={}),null==e.overlays&&(e.overlays={}),
// Store the value
this.layersControlConfigValue=e,
// Update the map
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnInit=function(){var e=this;
// Init the map
this.leafletDirective.init(),
// Set up control outside of angular to avoid change detection when using the control
this.zone.runOutsideAngular(function(){
// Set up all the initial settings
// Set up all the initial settings
e.controlLayers.init({},e.layersControlOptions).addTo(e.leafletDirective.getMap())}),this.updateLayers()},e.prototype.ngOnDestroy=function(){this.layersControlConfig={baseLayers:{},overlays:{}},this.controlLayers.getLayersControl().remove()},e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.updateLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t){
// Run the baselayers differ
if(null!=this.baseLayersDiffer&&null!=this.layersControlConfigValue.baseLayers){var n=this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);this.controlLayers.applyBaseLayerChanges(n)}
// Run the overlays differ
if(null!=this.overlaysDiffer&&null!=this.layersControlConfigValue.overlays){n=this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);this.controlLayers.applyOverlayChanges(n)}}},e.decorators=[{type:n.Directive,args:[{selector:"[leafletLayersControl]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:t},{type:n.KeyValueDiffers},{type:n.NgZone}]},e.propDecorators={layersControlConfig:[{type:n.Input,args:["leafletLayersControl"]}],layersControlOptions:[{type:n.Input,args:["leafletLayersControlOptions"]}]},e}(),f=/** @class */function(){function e(){}return e.mapToArray=function(e){var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(e[n]);return t},e}(),y=/** @class */function(){function e(e,t,n){this.differs=t,this.zone=n,this.leafletDirective=new o(e),this.controlLayers=new l(this.zone),this.baseLayersDiffer=this.differs.find({}).create()}return Object.defineProperty(e.prototype,"baseLayers",{get:function(){return this.baseLayersValue},set:
// Set/get baseLayers
function(e){this.baseLayersValue=e,this.updateBaseLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnDestroy=function(){this.baseLayers={},this.controlLayers.getLayersControl().remove()},e.prototype.ngOnInit=function(){var e=this;
// Init the map
this.leafletDirective.init(),
// Create the control outside angular to prevent events from triggering chnage detection
this.zone.runOutsideAngular(function(){
// Initially configure the controlLayers
// Initially configure the controlLayers
e.controlLayers.init({},e.layersControlOptions).addTo(e.leafletDirective.getMap())}),this.updateBaseLayers()},e.prototype.ngDoCheck=function(){this.updateBaseLayers()},e.prototype.updateBaseLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t&&null!=this.baseLayersDiffer){var n=this.baseLayersDiffer.diff(this.baseLayersValue);this.controlLayers.applyBaseLayerChanges(n).changed()&&this.syncBaseLayer()}},
/**
     * Check the current base layer and change it to the new one if necessary
     */
/**
         * Check the current base layer and change it to the new one if necessary
         */
e.prototype.syncBaseLayer=
/**
         * Check the current base layer and change it to the new one if necessary
         */
function(){var e,t=this,n=this.leafletDirective.getMap(),o=f.mapToArray(this.baseLayers);
// Search all the layers in the map to see if we can find them in the baselayer array
n.eachLayer(function(t){e=o.find(function(e){return t===e})}),
// Did we find the layer?
null!=e?
// Yes - set the baselayer to the one we found
this.baseLayer=e:
// No - set the baselayer to the first in the array and add it to the map
0<o.length&&(this.baseLayer=o[0],
// Add layers outside of angular to prevent events from triggering change detection
this.zone.runOutsideAngular(function(){t.baseLayer.addTo(n)}))},e.decorators=[{type:n.Directive,args:[{selector:"[leafletBaseLayers]"}]}],
/** @nocollapse */
e.ctorParameters=function(){return[{type:t},{type:n.KeyValueDiffers},{type:n.NgZone}]},e.propDecorators={baseLayers:[{type:n.Input,args:["leafletBaseLayers"]}],layersControlOptions:[{type:n.Input,args:["leafletLayersControlOptions"]}]},e}(),h=/** @class */function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e.decorators=[{type:n.NgModule,args:[{exports:[t,r,s,p,y],declarations:[t,r,s,p,y]}]}],e}(),c=/** @class */function(){function o(e,t,n){this.type=e,this.url=t,this.options=n}
/**
     * Creates a TileLayer from the provided definition. This is a convenience function
     * to help with generating layers from objects.
     *
     * @param layerDef The layer to create
     * @returns {TileLayer} The TileLayer that has been created
     */
/**
         * Creates a TileLayer from the provided definition. This is a convenience function
         * to help with generating layers from objects.
         *
         * @param layerDef The layer to create
         * @returns {TileLayer} The TileLayer that has been created
         */return o.createTileLayer=
/**
         * Creates a TileLayer from the provided definition. This is a convenience function
         * to help with generating layers from objects.
         *
         * @param layerDef The layer to create
         * @returns {TileLayer} The TileLayer that has been created
         */
function(e){var t;switch(e.type){case"xyz":t=a.tileLayer(e.url,e.options);break;case"wms":default:t=a.tileLayer.wms(e.url,e.options)}return t},
/**
     * Creates a TileLayer for each key in the incoming map. This is a convenience function
     * for generating an associative array of layers from an associative array of objects
     *
     * @param layerDefs A map of key to tile layer definition
     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
     */
/**
         * Creates a TileLayer for each key in the incoming map. This is a convenience function
         * for generating an associative array of layers from an associative array of objects
         *
         * @param layerDefs A map of key to tile layer definition
         * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
         */
o.createTileLayers=
/**
         * Creates a TileLayer for each key in the incoming map. This is a convenience function
         * for generating an associative array of layers from an associative array of objects
         *
         * @param layerDefs A map of key to tile layer definition
         * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
         */
function(e){var t={};for(var n in e)e.hasOwnProperty(n)&&(t[n]=o.createTileLayer(e[n]));return t},
/**
     * Create a Tile Layer from the current state of this object
     *
     * @returns {TileLayer} A new TileLayer
     */
/**
         * Create a Tile Layer from the current state of this object
         *
         * @returns {TileLayer} A new TileLayer
         */
o.prototype.createTileLayer=
/**
         * Create a Tile Layer from the current state of this object
         *
         * @returns {TileLayer} A new TileLayer
         */
function(){return o.createTileLayer(this)},o}();e.LeafletModule=h,e.LeafletDirective=t,e.LeafletDirectiveWrapper=o,e.LeafletTileLayerDefinition=c,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-leaflet.js.map
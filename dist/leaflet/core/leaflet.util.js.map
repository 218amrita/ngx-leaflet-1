{"version":3,"sources":["leaflet/core/leaflet.util.ts"],"names":[],"mappings":";AAAA;IAAA;IA6EA,CAAC;IA3EA;;;;;;;OAOG;IACI,qBAAS,GAAhB,UAAqB,IAA4B,EAAE,IAA4B;QAC9E,IAAI,QAAQ,GAA2B,EAAE,CAAC;QAE1C,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAClB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACF,CAAC;QACF,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAClB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACF,CAAC;QACF,CAAC;QAED,MAAM,CAAC,QAAQ,CAAC;IACjB,CAAC;IAED;;;;;;;;OAQG;IACI,uBAAW,GAAlB,UAAsB,IAA0B,EAAE,IAA0B;QAC3E,IAAI,QAAQ,GAA2B,EAAE,CAAC;QAE1C,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAElB,iCAAiC;YACjC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACF,CAAC;YAED,oDAAoD;YACpD,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBAClB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;oBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC5B,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACpB,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;QAED,MAAM,CAAC,QAAQ,CAAC;IACjB,CAAC;IAEM,sBAAU,GAAjB,UAAqB,GAA2B;QAC/C,IAAI,QAAQ,GAAQ,EAAE,CAAC;QAEvB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YACnB,EAAE,CAAC,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3B,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACvB,CAAC;QACF,CAAC;QAED,MAAM,CAAC,QAAQ,CAAC;IACjB,CAAC;IACF,kBAAC;AAAD,CA7EA,AA6EC,IAAA;AA7EY,kCAAW","file":"leaflet.util.js","sourcesContent":["export class LeafletUtil {\n\n\t/**\n\t * Combine two associative arrays in a shallow manner. Where there are duplicate properties,\n\t * the value in the second object will overwrite the value of the first object\n\t *\n\t * @param aMap The first object\n\t * @param bMap The second object\n\t * @returns {{}} The aggregate of both objects\n\t */\n\tstatic mergeMaps<T> (aMap: { [ key: string ]: T }, bMap: { [ key: string ]: T }): { [ key: string ]: T } {\n\t\tlet toReturn: { [ key: string ]: T } = {};\n\n\t\tif (null != aMap) {\n\t\t\tfor (let k in aMap) {\n\t\t\t\tif (aMap.hasOwnProperty(k)) {\n\t\t\t\t\ttoReturn[k] = aMap[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (null != bMap) {\n\t\t\tfor (let k in bMap) {\n\t\t\t\tif (bMap.hasOwnProperty(k)) {\n\t\t\t\t\ttoReturn[k] = bMap[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toReturn;\n\t}\n\n\t/**\n\t * Subtracts the properties of an associative array in a shallow manner.\n\t * Where there are duplicate properties, the properties will be removed\n\t * from the first object.\n\t *\n\t * @param aMap The object from which to subtract properties\n\t * @param bMap The object containing properties to subtract\n\t * @returns {{}}\n\t */\n\tstatic mapSubtract<T>(aMap: { [key: string]: T }, bMap: { [key: string]: T }): { [ key: string ]: T } {\n\t\tlet toReturn: { [ key: string ]: T } = {};\n\n\t\tif (null != aMap) {\n\n\t\t\t// Copy all of aMap into toReturn\n\t\t\tfor (let k in aMap) {\n\t\t\t\tif (aMap.hasOwnProperty(k)) {\n\t\t\t\t\ttoReturn[k] = aMap[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's a bMap, delete all bMap keys from aMap\n\t\t\tif (null != bMap) {\n\t\t\t\tfor (let k in bMap) {\n\t\t\t\t\tif (bMap.hasOwnProperty(k)) {\n\t\t\t\t\t\tdelete toReturn[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toReturn;\n\t}\n\n\tstatic mapToArray<T>(map: { [ key: string ]: T }): T[] {\n\t\tlet toReturn: T[] = [];\n\n\t\tfor (let k in map) {\n\t\t\tif (map.hasOwnProperty(k)) {\n\t\t\t\ttoReturn.push(map[k]);\n\t\t\t}\n\t\t}\n\n\t\treturn toReturn;\n\t}\n}\n"]}
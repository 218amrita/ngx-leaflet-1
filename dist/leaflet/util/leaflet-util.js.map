{"version":3,"sources":["leaflet/util/leaflet-util.ts"],"names":[],"mappings":";AAAA;IAAA;IAiEA,CAAC;IA/DA;;;;;;;OAOG;IACI,qBAAS,GAAhB,UAAiB,IAAQ,EAAE,IAAQ;QAClC,IAAI,QAAQ,GAAG,EAAE,CAAC;QAElB,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAClB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACF,CAAC;QACF,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAClB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACF,CAAC;QACF,CAAC;QAED,MAAM,CAAC,QAAQ,CAAC;IACjB,CAAC;IAED;;;;;;;;OAQG;IACI,uBAAW,GAAlB,UAAmB,IAAQ,EAAE,IAAQ;QACpC,IAAI,QAAQ,GAAG,EAAE,CAAC;QAElB,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;YAElB,iCAAiC;YACjC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,CAAC;YACF,CAAC;YAED,oDAAoD;YACpD,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC;gBAClB,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC;oBACpB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC5B,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACpB,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;QAED,MAAM,CAAC,QAAQ,CAAC;IACjB,CAAC;IACF,kBAAC;AAAD,CAjEA,AAiEC,IAAA;AAjEY,mBAAW,cAiEvB,CAAA","file":"leaflet-util.js","sourcesContent":["export class LeafletUtil {\n\n\t/**\n\t * Combine two associative arrays in a shallow manner. Where there are duplicate properties,\n\t * the value in the second object will overwrite the value of the first object\n\t *\n\t * @param aMap The first object\n\t * @param bMap The second object\n\t * @returns {{}} The aggregate of both objects\n\t */\n\tstatic mergeMaps(aMap: {}, bMap: {}) {\n\t\tlet toReturn = {};\n\n\t\tif (null != aMap) {\n\t\t\tfor (let k in aMap) {\n\t\t\t\tif (aMap.hasOwnProperty(k)) {\n\t\t\t\t\ttoReturn[k] = aMap[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (null != bMap) {\n\t\t\tfor (let k in bMap) {\n\t\t\t\tif (bMap.hasOwnProperty(k)) {\n\t\t\t\t\ttoReturn[k] = bMap[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toReturn;\n\t}\n\n\t/**\n\t * Subtracts the properties of an associative array in a shallow manner.\n\t * Where there are duplicate properties, the properties will be removed\n\t * from the first object.\n\t *\n\t * @param aMap The object from which to subtract properties\n\t * @param bMap The object containing properties to subtract\n\t * @returns {{}}\n\t */\n\tstatic mapSubtract(aMap: {}, bMap: {}) {\n\t\tlet toReturn = {};\n\n\t\tif (null != aMap) {\n\n\t\t\t// Copy all of aMap into toReturn\n\t\t\tfor (let k in aMap) {\n\t\t\t\tif (aMap.hasOwnProperty(k)) {\n\t\t\t\t\ttoReturn[k] = aMap[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's a bMap, delete all bMap keys from aMap\n\t\t\tif (null != bMap) {\n\t\t\t\tfor (let k in bMap) {\n\t\t\t\t\tif (bMap.hasOwnProperty(k)) {\n\t\t\t\t\t\tdelete toReturn[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn toReturn;\n\t}\n}\n"]}